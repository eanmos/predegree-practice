% Устанавливаем размер шрифта в 14 пунктов.
% Рекомендованный размер шрифта по ГОСТ 7.32-2017 ---
% не менее 12 пунктов [1, §́ 6.1.1].
\documentclass[14pt,russian]{extarticle}

\renewcommand\arraystretch{1.5}
\usepackage{tabularx}
\usepackage{rotating}

\usepackage{amsmath}

\usepackage[shortcuts]{extdash}
\usepackage{array}
\usepackage{graphicx}

\usepackage[math]{cellspace}
\cellspacetoplimit 4pt
\cellspacebottomlimit 4pt

% Настройка формат страниц и величины полей согласно [1, § 6.1.1].
\usepackage[
	a4paper,
	bindingoffset=0pt,
	left=30mm,
	right=15mm,
	top=20mm,
	bottom=20mm,
	footskip=10mm,
	includeheadfoot,
	]{geometry}

% Просим LaTeX попытаться избежать строк- \enquote{сирот» и «вдов}.
\usepackage[all]{nowidow}

% Поддержка кириллицы и кодировки UTF-8.
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,main=russian]{babel}

% Поддержка вставки изображений в документ.
\usepackage{graphicx}
\graphicspath{{./img/}}

% Плавающее положение изображений в документе.
\usepackage{float}

% Из ГОСТ.32-2017: «Иллюстрации при необходимости могут иметь наименование и
% пояснительные данные (подрисуночный текст). Слово "Рисунок", его номер и через
% тире наименование помещают после пояснительных данных и располагают в центре
% под рисунком без точки в конце» [1, 6.5.7].
%
% TODO: заменить en dash (короткое тире) на em dash (тире).
\usepackage[figurename=Рисунок,labelsep=endash]{caption}
% TODO
% 6.6.3 Наименование таблицы, при ее* наличии, должно отражать ее содержание, быть
% точным, кратким. Наименование следует помещать над таблицей слева, без абзацного
% отступа в следующем формате: Таблица Номер таблицы - Наименование таблицы.
% Наименование таблицы приводят с прописной буквы без точки в конце.
\captionsetup[table]{singlelinecheck=off}

% Из ГОСТ.32-2017: «Допускается нумеровать иллюстрации в пределах раздела
% отчета. В этом случае номер иллюстрации состоит из номера раздела и
% порядкового номера иллюстрации, разделенных точкой: Рисунок 2.1.» [1, 6.5.6].
\renewcommand{\thefigure}{\arabic{section}.\arabic{figure}}

% Поддержка автоматических переносов слов.
\usepackage{hyphenat}

% Из ГОСТ 7.32-2017: "Страницы отчета следует нумеровать арабским
% цифрами, соблюдая сквозную нумерацию по всему тексту отчета,
% включая приложения" [1, § 6.3.1].
\pagenumbering{arabic}

% Рекомендуемый по ГОСТ 7.32-2017 тип шрифта для основного текста отчета - Times
% New Roman [1, § 6.1.1].
%
% Способ задания шрифта Times New Roman с поддержкой кириллицы подсмотрен в
% источнике [2].
\usepackage{tempora}
% Полуторный интервал рекомендован [1, § 6.1.1].
\usepackage{setspace}
\onehalfspacing

% ГОСТ 7.32-2017: "Абзацный отступ должен быть одинаковым по всему
% тексту отчета и равен 1,25 см." [1, § 6.1.1].
\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

% LaTeX по-умолчанию выравнивает текст по ширине, что и требуется по
% ГОСТ.32-2017.
% TODO: привести ссылку на требование.

% Формат заголовков: размер шрифта, интерлиньяж и расстояние между
% порядковым номером и сами заголовком. Последнее берется равным абзацному
% отступу (1,25 см).
%
% TODO: найти, какие требования к оформлению заголовков предъявляет [1].
%
% FIXME: raggedright должен отключать переносы в заголовках, но он работает.
\usepackage[raggedright]{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\section}{\normalfont\fontsize{18pt}{1\baselineskip}\bfseries}{\thesection}{1.25cm}{}
\titleformat{\subsection}{\normalfont\fontsize{16pt}{1\baselineskip}\bfseries}{\thesubsection}{1.25cm}{}
\titleformat{\subsubsection}{\normalfont\fontsize{14pt}{1\baselineskip}\bfseries}{\thesubsubsection}{1.25cm}{}
\titleformat{\paragraph}{\normalfont\fontsize{14pt}{1\baselineskip}\bfseries}{\theparagraph}{1.25cm}{}

% Задаем тире как символ для элементов в списках.
% TODO: найти, какие требования предъявляет [1] к оформлению списков.
\renewcommand{\labelitemi}{---}

% Поддержка библиографического списока по ГОСТ 7.0.5-2008.
% https://github.com/odomanov/biblatex-gost
\usepackage[autostyle]{csquotes}
\selectlanguage{russian}
\usepackage[backend=biber,style=gost-numeric,sorting=none]{biblatex}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}
\addbibresource{bibliography.bib}

% Из ГОСТ.32-2017: «Заголовки структурных элементов следует располагать в
% середине строки без точки в конце, прописными буквами, не подчеркивая. Каждый
% структурный элемент и каждый раздел основной части отчета начинают с новой
% страницы» [1, § 6.2.1].
\newcommand*\gostStructureElement[1]{
	\clearpage
	\section*{\centerline{\MakeUppercase{#1}}}
	\addcontentsline{toc}{section}{\MakeUppercase{#1}}
}

% Из ГОСТ.32-2017: «Использование курсива допускается для обозначения объектов
% (биология, геология, медицина, нанотехнологии, генная инженерия и др.) и
% написания терминов (например, in vivo, in vitro) и иных объектов и терминов на
% латыни» [1, § 6.1.1].
\newcommand*\obj[1]{\textit{#1}}
\newcommand*\term[1]{\textit{#1}}

% То же, что и выше для содержания.
\usepackage{etoc}
\etocsettocstyle{\centerline{\MakeUppercase{\textbf{Содержание}}}}

% TODO https://tex.stackexchange.com/questions/410250/understanding-line-height-line-spacing-baselineskip-in-latex
\usepackage{fix-cm}

%-------------------------------------------------------------------------------
%
% НАЧАЛО ДОКУМЕНТА
%
%-------------------------------------------------------------------------------

\title{Выпускная квалификационная работа "Разработка компилятора языка C для
образовательных целей"}
\author{Нефедов Д. В.}
\date{Октябрь 2021}

\begin{document}
%-----------------------------------------------------------------
% 4 старница
%-----------------------------------------------------------------

\clearpage
\thispagestyle{empty}
\begin{center}
	\singlespacing

	ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ
	ВЫСШЕГО ОБРАЗОВАНИЯ \enquote{САРАТОВСКИЙ ГОСУДАРСТВЕННЫЙ
	ТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ ИМЕНИ ГАГАРИНА Ю.А.}

	\bigskip
	\bigskip

	\textit{ИНСТИТУТ ПРИКЛАДНЫХ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ И
	КОММУНИКАЦИЙ}

	\bigskip
	\bigskip

	Кафедра \enquote{Прикладные информационные технологии}

	\bigskip
	\bigskip
	\bigskip
	\bigskip

	\singlespacing

	{\Large Отчет по производственной практике (НИР)}

	\bigskip
	\bigskip
	\bigskip

\begin{flushleft}
	\begin{tabularx}{\textwidth}{
		|>{\raggedright\arraybackslash}X
		|>{\raggedright\arraybackslash}X| }

		\hline
		Место прохождения практики &
		Администрация Калининского муниципального района Саратовской области \\

		\hline
		Время прохождения практики &
		19 апреля 2022 г. по 3 мая 2022 г. \\

		\hline
	\end{tabularx}

	\bigskip

	\begin{tabular}{|S{p{6cm}}|S{p{4.75cm}}|S{p{2cm}}|S{p{2cm}}|}
		\hline
		&
		ФИО &
		Подпись &
		Дата \\

		\hline
		Выполнил студент группы б1-ПИНФ41 &
		Нефедов Данил Вадимович &
		&
		\\

		\hline
		Руководитель от кафедры &
		Бровко Александр Валерьевич &
		&
		\\

		\hline
	\end{tabular}

	\bigskip

	\begin{tabular}{|S{p{6.65cm}}|S{p{9cm}}|}
		\hline
		Итоговая оценка по защите результатов деятельности на практике &
		~\\
		\hline
	\end{tabular}
\end{flushleft}

\vfill
	Саратов 2021
\end{center}

%----------------------------------------------------------------
% НАЧАЛО
%-----------------------------------------------------------------


\clearpage
\tableofcontents

\gostStructureElement{Введение}

Цели преддипломной практики: получение практических навыков
выполнения исследований, разработки и реализации архитектуры
программного обеспечения в ходе выполнения
научно-исследовательской работы в области разработки компиляторов.

Задачи преддипломной практики:

\begin{itemize}
	\item Анализ предметной области и существующих аналогов
		программного обеспечения компиляторов, направленных на
		образование.
	\item Разработка архитектуры программного обеспечения.
	\item Разработка программного обеспечения компилятора с
		возможностью интроспекции всех промежуточных представлений, а
		также графический пользовательский интерфейс к нему.
	\item Ознакомление с основными требованиями, предъявляемыми к
		содержанию и оформлению научно-исследовательских работ.
	\item Развитие навыков оформления рабочих результатов в виде
		научно-технических отчетов.
\end{itemize}

Преддипломная практика направлена на формирование навыковой
составляющей следующих компетенций:

\begin{itemize}
	\item ОК-7: способность к самоорганизации и самообразованию.
	\item ПК-6: способность собирать детальную информацию для
		формализации требований пользователей заказчика.
	\item ПК-24: способность готовить обзоры научной литературы и
		электронных информационно-образовательных ресурсов для
		профессиональной деятельности.
\end{itemize}

Компилятор многим видется как некий \enquote{магический артефакт},
своеобразный черный ящик, созданный могучими
волшебниками-программистами, недоступный для понимания простым
смертным.

Книги, посвященные созданию компляторов, внушают благоговейный
ужас каждому программисту, так же как \enquote{Критика чистого
разума} Канта внушает ужас каждому философу. Чрезвычайная
академичность материала и необходимость пробираться через тонны
математических конструкций и абстрактных построений твердо
закрепила за этими книгами и, соответственно, предметной областью,
репутацию непреступных крепостей мира компьютерных наук \cite{Aho1}.

Серьезные компиляторы чрезвычайно сложны для понимания, включают в
себя десятки миллионов строк кода и, порой, десятилетия труда
сотен инженеров.

На сегодня существует довольно серьезная проблема в отрасли:
\textit{найти специалистов в сфере разработки комплияторов
сложно} \cite{se}.

Во многом в этом виновата некоторая элитарность, высокий порог
вхождения и низкая популярность предметной области относительно
современных трендов, например таких как веб-программирование.

% TODO: переписать, это уже не введение.
Решение данной проблемы должно быть комплексным: необходимо
устранить сразу несколько факторов, среди которых можно выделить:
а) высокий порог вхождения в предметную область; б) низкая
популярность по сравнению с современными \enquote{модными} технологиями;
в) стереотип о сухости и академичности темы.

Обратим особое внимание на первую проблему из списка и постараемся
понять, чем она может быть обусловлена.

Высокий порог вхождения в любою технологию или предметную область
среди прочего может быть обусловлен: а) отсутствием доступных
учебных материалов; б) необходимостью иметь глубокие базовые
знания и навыки, т.н. \textit{background}.

Целью выпускной квалификационной работы поставлено решение
проблемы высокого порога вхождения в предметную область.

В качестве средства для достижения цели была поставлена задача
создания компилятора языка C, который сможет послужить хорошей
отправной точкой в изучении предметной области начинающими
специалистами.

\pagebreak
\section{Описание задачи и анализ существующих решений}

\subsection{Описание предметной области}

\textit{Компилятор} --- это просто программа по преобразованию
текста из одного вида в другой. Входной формат текста называется
\textit{языком исходного кода}, а выходной --- \textit{целевым
языком} \cite{Grune}.

Сама необходимость такого преобразования заключается в том, что
языком исходного кода является некоторый язык программирования
высокого уровня, а в качестве целевого языка выступает язык
ассемблера. Программа на языке высокого уровня в абсолютном
большинстве случаев просто не может быть напрямую исполнена на
CPU, который \enquote{понимает} только язык ассемблера.

Обычно процесс компиляции заключается в том, чтобы сперва
проанализировать исходный код и построить его
\textit{семантическую интерпретацию}, а затем уже
\textit{синтезировать} соответствующий код на целевом языке.

Та часть компилятора, которая занимается анализом исходного кода
называется \textit{фронтендом}, а часть, которая синтезирует код
на целевом языке --- \textit{бекендом}. В хорошо спроектированном
компиляторе фронтенд не имеет никакого представления о целевом
языке, а бекенд --- об исходном, единственно общее между ними ---
это знание семантического представления.

Со временем сложилась устоявшаяся структура как фронтенда, так и
бекенда компилятора, ставшая уже классической. Ниже вкратце будут
рассмотрены модули этой структуры.

Самым первым модулем фронтенда компилятора считается
\textit{лексический анализатор}. Его задача заключается в том,
чтобы превратить поток символов исходного текста в ряд отдельных
лексических единиц языка, называемых \textit{токенами}. К примеру,
таких как: целочисленные константы, идентификаторы, фигурные и
круглые скобки.

После обработки входного текста лексическим анализатором
полученный поток токенов подается на вход \textit{синтаксическому
анализатору}, который превращает этот ряд токенов в
\textit{синтаксическое дерево}, соответствующее синтаксису
исходного языка.

Стоит отметить, что фазы парсинга исходного текста хорошо изучены
и формализованы \cite{Sermutlu}. Существует отдельная область
компьютерной лингвистики, которая изучает формальные языки. Особо
отметим достижения профессора Ноама Чомского, который сумел
составить классификацию всех формальных языков, суммаризованной в
иерархии названной его именем --- \textit{иерархии Чомского}. Это
позволило построить математический аппарат и создать мощные
формализмы, способные проводить разбор формальных языков различных
видов.

% FIXME: превратить в сноску.
Интересно, что в некоторых компиляторах стадии лексического и
синтаксического анализа объединяются. Дело в том, что регулярные
языки, которые достаточно мощны для разбора исходного текста на
лексические единицы, находятся ниже контекстно-независимых языков
в вышеупомянутой иерархии. Иначе говоря, любой регулярный язык
является подмножеством некоторого контекстно-независимого. Это
позволяет описать лексическую структуру языка прямо в
контекстно-независимой грамматике \cite{so}.

Следующим шагом итоговое синтаксическое дерево передается на вход
\textit{семантическому анализатору}, который выполняет
семантический анализ программы, возвращая в качестве результата
\textit{абстрактное синтаксическое дерево} (англ. \textit{Abstract
Syntax Tree}, AST). Помимо всего прочего, такое дерево лишено
излишних деталей синтаксического дерева, которые затрудняют
дальнейшую его обработку \cite{so2}.

Следующей и последней задачей фронтенда является генерация
\textit{промежуточного представления} (англ. \textit{intermediate
representation}, кратк. \textit{IR}) из AST дерева. Это
представление, в отличие от AST, является языконезависимым и
подходит для представления кода на разных языках программирования.
Обычно IR почти полностью состоит из выражений и операторов потока
управления.

С этого этапа начинается работа бекенда компилятора, где на первом
этапе над полученным IR выполняются \textit{проходы оптимизации}
(англ. \textit{optimization passes}) с целью увеличения
эффективности кода. Простейшим примером такого прохода является
\textit{свертка констант} при котором в выражениях заранее
вычисляются операнды, значение которых известно во время
компиляции \cite{Muchnick}.

После завершения всех проходов оптимизации IR передается модулю
\textit{кодогенерации}, задача которого состоит в том, чтобы из
полученного IR сгенерировать код на целевом языке. Кодогенератор
выбирает соответствующие нужные инструкции, распределяет машинные
регистры для хранения значений и размещает инструкции в нужном
порядке.

После генерации кода на целевом языке компилятор может выполнить
так называемые \textit{микро-оптимизации} (англ. \textit{peephole
optimizations}) \cite{Fischer}, которые изменяют небольшой набор
инструкций на эквивалентный набор, который имеет большую
производительность.

Наконец, после всех этих манипуляций, компилятор может выдать
финальный код на целевом языке.

\subsection{Постановка задачи}

Разрабатываемый компилятор толжен послужить хорошей отправной
точкой для всех, кто пытается разобраться в области построения
компиляторов. Несмотря на субъективность формулировки задачи, что
вероятно пресуще всем работам в области образовательных процессов,
мы постараемся выделить конкретные требования к компиляторы.

% TODO: написать про вариации принципа KISS: бритву Оккама,
% высказывание Леонардо да Винчи, Шекспира, Эйнштейна и прч.

% TODO: вероятно вынести описание принципа в примечание.

Первым и довольно очевидным требованием к решению будет его
\textit{простота}. Основополагающим принципом при разработке
компилятора должен быть так называемый \textit{принцип KISS}. Он
был предложен в 1960 военно-морскими силами США и гласит, что
большинство систем работают лучше, если они сделаны как можно
проще, а следовательно простота должна быть ключевой целью
проектирования. Справедливость этого тезиса подтверждается его
многочисленными вариациями, всплывающими в культуре на протяжении
веков \cite{Misra}.

Следующим требованием выделим \textit{необходимость показать
наиболее идеоматичные и устоявшиеся алгоритмы, методы и
архитектуру построения компилятора}. Это позволит учащимся лучше
понять основополагающие принципы работы программы, а кроме того
даст фундаментальные знания предмета, которые в дальнейшем можно
будет применить как в индустрии, так и в академической сфере.

% TODO: упомянуть тот вопрос на Reddit.

Вспомним, что компиляция это преобразование текста с одного языка
в другой. Так как обычно эти языки находятся на очень разных
уровнях абстракции и в целом сильно отличаются друг от друга, у
нас нет никакого способа произвести преобразование напрямую.
Поэтому мы придумали промежуточные языки и превратили процесс
компиляции в ряд простых преобразований из одного языка в другой.

% TODO: упомянуть про AST dump в Clang.

Таким образом, следующим нашим требованием будет реализовать
\textit{возможность просмотра всех промежуточных представлений
исходного кода}. Это поможет учащимся получить так называемый
\textit{инсайт} о том, что действительно происходит в процессе
компиляции.

% TODO: переписать по-человечески про выбор языка C.

Теперь нам необходимо выбрать исходный язык для нашего
компилятора. Имеет смысл предъявить к языку следующие требования:

\begin{enumerate}
	\item \textit{Распространенность}. Язык должен быть известен
		наиболее широкому кругу учащихся. Нельзя написать компилятор
		языка X, будучи незнакомым с языком\,X.
	\item \textit{Широкое применение}. Язык должен использовать в
		реальной работе, это не должен быть \enquote{игрушечный} язык, иначе
		учащимся будет просто не интересно работать над ним.
	\item \textit{Простота}. Язык должен быть максимально простым и
		в то же время использоваться в реальной работе.
\end{enumerate}

Под все эти критерии идеально подходит язык С:

\begin{enumerate}
	\item Язык C является вводным языком для большинства
		академических курсов, посвященных информатике и компьютерным
		наукам \cite{Dice}.
	\item Уже на протяжении сорока лет является одним из самых
		популярных языков в мире. Он используется для разработки самых
		распространенных программных решений, таких как Microsoft
		Windows, Linux, OpenSSL и миллионов других.
	\item Несмотря на свою мощь и выразительность язык крайне прост
		как для написания и чтения кода, так и для компиляции
		\cite{CLang}.
\end{enumerate}

% TODO: добавить источник.
Стоит отметить, что понятие \enquote{язык C} это своего рода
сфеерический конь в вакууме. Язык появился в 70-х годах прошлого
века и за все это время претерпел колоссальное количество,
как оффициальных так и не очень, изменений, что породило огромное
количество версий и диалектов языка.

% TODO: добавить источник.
Оффициальные версии языка определяются организациями ISO и IEC, а
конкретно комитетом ISO/IEC JTC 1/SC 22, который отвечает за
разработку и принятие стандарта языка \cite{ISO9899}.

Мы должны помнить, что нашей задачей является написание
дидактического примера, а не промышленного компилятора. Поэтому мы
должны отсечь все возможности языка, которые будут усложнять
реализацию, не привнося при этом никакого существенного вклада в
образовательную ценность проекта.

% TODO: добавить источник.
Когда-то давно комитет С89 при разработке самого первого стандарта
языка С поставил для себя задачу \enquote{сохранить дух
языка}~\cite{Rationale}. Такой же цели должны придерживаться и
мы: убрать лишнее из реализации, сохранив при этом дух языка.

Следующим шагом будет выбор целевого языка компилятора, другими
словами нам необходимо выбрать под какую платформу будет
генерироваться ассемблерный код.

В целом все языки ассемблера крайне похожи между собой, потому что
нижележащие принципы работы любого из них примерно
одинаковы~\cite{Harris}. Наиболее очевидным и, в то же время,
подходящим выбором для нас будет архитектура Intel 64: она уже
многие годы доминирует на рынке персональных компьютеров и
подавляющие число студенов имеют процессоры, которые реализуют
именно её.

Одним из самых больших недостатков этой архитектуры является её
сложность, ставшая результатом давней политики корпорации Intel по
сохранению обратной совместимости их процессоров. Мы могли бы
выбрать архитектуру ARM или RISC-V, которые более просты и
минималистичны~\cite{Hennesy}, но:

\begin{enumerate}
	\item Для Intel 64 написано колоссально большее количество
		учебных материалов чем по любой другой архитектуре.
	\item Сложности Intel 64 в полной мере проявляются только при
		очень низкоуровневом программирование, что в нашем случае
		нивелирует эффекты этой особенности архитектуры.
	\item Для запуска кода под архитектуру, отличающуюся от родной
		архитектуры процессора, студентам придется использовать
		средства виртуализации, которые требуют дополнительного
		обучения и могут быть несовместимы с некоторым оборудованием.
\end{enumerate}

% TODO: написать про язык реализации.

Резюмируя все вышеизложенное, сформулируем нашу задачу:
\textit{разработать дидактический пример компилятора языка C,
поддерживающий основные конструкции языка и обеспечивающий
возможность просмотра всех промежуточных представлений исходного
кода, применив при разработке идеоматичные алгоритмы и методы
построения компиляторов}.

\subsection{Обзор существующих аналогов}

Перед реализация программного обеспечения необходимо
проанализировать аналогичное или схожее программное обеспечение,
существующее на рынке, провести сравнение с разрабатываемым
решением, а также возможность его использования для решения
поставленных задач.

\subsubsection{8cc}

Одним из самых популярных из простых компиляторов языка С является
8сс, который реализует язык C11 и способен скомпилировать сам
себя.

При его написании автор старался сохранять код как можно более
простым и читаемым, чтобы он мог послужить хорошим примером для
узучения различных техник, применяемых в компиляции.

Стадии препроцессинга и лексического анализа объединены в один
проход. Используется, написанный в ручную, парсер рекурсивного
спуска, который строит сразу AST, пропуская этап построения
синтаксического дерева.

Компилятор предоставляет возможность вывести результаты
препроцессинга, построения AST дерева и ассемблерного кода под
платформу Intel 64.

\subsubsection{Nanopass Framework}

Nanopass Framework является встраиваемым предметно-ориентированным
языком для создания компиляторов, который фокусируется на создании
небольших этапов прохода по исходному кода и большого количества
промежуточных представлений. Фреймворк уменьшает количество
вспомогательного кода, требуемого для создания компилятора, что
сделать их более простыми для понимания и поддержки.

Фреймворк поощряет создание небольших проходов компиляции крайне
незначительных по сложности. Например, это могут быть такие
проходы как \enquote{удаление всех точек с запятой} или \enquote{преобразование
операции присваивания}. Последовательное применение десятков или
даже сотен таких проходов позволяет получить программу на целевом
языке.

Существуют реализации Nanopass на таких языках как Scheme и
Racket, оба из которых являются функциональными.

\subsubsection{AMaCC}

Проект AMaCC (расш. \textit{Arguably Minimalist ARM C Compiler})
--- это компилятор подмножества языка C89 под 32-х битную
архитектуру ARM. Создавался в педагогических целях для изучения
компиляторов, линкеров и загрузчиков.

Реализует две модели выполнения: JIT-компиляция под ARM-бекенд, а
также генерация исполняемых файлов в формате ELF для систем
GNU/Linux.

AMaCC использует смешение рекурсивного спуска и высходящего
парсинга. Простое стековое AST генерируется через вызовы функций
парсинга \texttt{stmt} и \texttt{expr}, на вход которым лексер
подает токены. Функция \texttt{expr} выполняет простые оптимизация
над литералами. Полученный AST преобразуется в стековое VM IR
функцией \texttt{gen}. Наконец, функция \texttt{codegen}
генерирует ARM32 инструкции из IR, которые могут быть либо
выполнены функцией \texttt{jit}, либо переданы фунции
\texttt{elf32} для генерации исполняемого файла.

\subsubsection{catc}

Компилятор catc поддерживает подмножество языка C и реализует
кодогенерацию под платформу Intel 64. Фазы лексического и
синтаксического анализа реализованны с помощью инструментов
построения парсеров Lex и Yacc.

\subsection{Сравнительный анализ существующих решений}

Найти дидактические примеры компилятора языка C довольно сложно,
так как таких разработок крайне мало. К сожалению, даже найденные
с таким трудом, готовые решения не удовлетворяют всем выдвинутым
требованиям к проекту.

После проведенного анализа существующих решений можно сделать
следующие выводы:

\begin{itemize}
	\item Большинство продуктов реализуют небольшое подмножество
		языка C, кроме компилятора \enquote{8cc}, который практически
		полностю реализует версию языка C11.

	\item Ни один из проанализированных компиляторов не
		предоставляет достаточных возможностей интроспекции
		промежуточных представлений исходного кода в процессе
		компиляции.
	
	\item Ни один из проанализрованных компиляторов не может служить
		хорошим примером идеоматичных и устоявшихся архитектурных
		принципов построения компиляторов. Ни в одном из них нет
		архитектуры, где каждый модуль представляет из себя
		законченный функциональный блок определенного этапа
		компиляции.
	
	\item Большая часть компиляторов содержит ненужный для решения
		поставленных нами задач функционал, что усложнит понимание их
		внутренней структуры и реализации студентам. В качестве
		примера такого функционала можно привести JIT-компиляцию в
		проекте \enquote{AMaCC} или почти полное соответствие стандарту C11
		в компиляторе \enquote{8cc}.
	
	\item Большинство проектов реализовано на той или иной версии
		языка C. Исключение составляет Nanopass Framework, который
		имеет реализации на языках Scheme и Racket.
	
	\item Большая часть компиляторов имеет довольно сложный для
		понимания исходный код. Сложность кода является, в том числе,
		следствием отсутствия деления программы на отдельные
		независимые функциональные узлы. В архитетуре решений
		наблюдается нарушения принципа единой ответственности.
\end{itemize}

Таким образом, было принятно решение разрабатывать свой
собственный компилятор языка C.

\begin{table}
	\caption{Сравнительная характеристика существующих решений и
	разрабатываемого проекта}

	\begin{tabularx}{\textwidth}{
		|>{\raggedright\arraybackslash}X
		|>{\raggedright\arraybackslash}X
		|>{\raggedright\arraybackslash}X
		|>{\raggedright\arraybackslash}X
		|>{\raggedright\arraybackslash}X| }

		\hline
			Параметр &
			8сс &
			AMaCC &
			Nanopass Framework &
			catc \\
		\hline

		Интроспе-кция & AST & IR & --- & нет \\
		\hline
		Целевая платформа & Intel 64 & ARM32 & --- & Intel 64 \\
		\hline
		Модульность архитектуры & слабая & средняя & --- & слабая \\
		\hline
		Сложность исходного кода & средняя & высокая & --- & средняя \\
		\hline
		Версия языка & C11 & подмно-жество C89 & --- & \textit{(не указано)} \\
		\hline
		Язык реализации & C11 & C89 & Scheme или Racket & C99 \\
		\hline
	\end{tabularx}
\end{table}

\section{Описание проектирование системы}

\subsection{Описание методов компиляции}

\subsubsection{Лексический анализ}

Первым шагом в процессе компиляции является лексический анализ.
Лексический анализтор преобразует сырой исходный код,
представленный в виде потока символов, поток групп символов,
которые мы называем \textit{токенами}. Токены --- это осмысленные
лексические единицы, из которых строится его грамматика.

Самым распространенным способом преобразования потока символов в
набор токенов является использование \textit{регулярных
выражений}.

Регулярные выражения широко применяются и за пределами области
разработки компиляторов. Утилита \texttt{grep} использует их для
поиска различных паттернов внутри текстовых файлов.

Набор строк, определяемый регулярными выражениями называется
\textit{регулярным множеством}. В контексте лексического анализа
каждый токен предствлен регулярным множеством, чья структура
определяется регулярным выражением. Конкретный элемент токена из
регулярного множества называют \textit{лексемой}.

Наше определение регулярного выражения начнется с конечного
множества символов, или \textit{словаря} (обозначается как
$\Sigma$). Обычно этот словарь является набором символов,
используемым компьютером.

Пустые, или нулевые, строки разрешены и обозначаются символом
$\lambda$. Этим символов обозначают пустой буфер в котором ни один
из символов еще не был распознан регулярным выражением. Этим же
символом обозначают опциональную часть токена, например,
целочисленный литерал может начинаться с плюса или минуса, а если
он беззнаковый, то с $\lambda$.

Строки строятся из символов множества $\Sigma$ при помощи операции
\textit{конкатенации} (объединение отдельных символов для
образования целостной строки).

Операция конкатенации расширяется на множество строк следующим
образом. Пусть $P$ и $Q$ множества строк. Символ $\in$ обозначает
принадлежность ко множеству. Если $s_1 \in P$ и $s_2 \in Q$, то
строка $s_{1}s_2 \in (P Q)$. Небольшие конечные множества обычно
обозначаются простым перечислением своих элементов. Скобки
исполбзуются для отделения выражений, а $|$, \textit{оператор
альтерации}, используется для обозначения альтернатив. Например,
множество десятичных цифр можно представить следующим образом:

$$
D = (0\, | \,1\, | \,2\, | \,3\, | \,4\, | \,5\, | \,6\, | \,7\, | \,8\, | \,9).
$$

Введем третью операцию --- \textit{замыкание Клини}. Оператор $^*$
обозначает постфиксную операцию замыкание Клини. Например, пусть
$P$ будет набором строк. Тогда $P^*$ представляет собой все строки,
сформированные конкатенацией нуля или более элементов из $P$.

\subsubsection{Синтаксический анализ}

Следующим этапом после лексического анализа является
\textit{синтаксический анализ} или \textit{парсинг}.

Регулярные языки, являясь чрезвычайно мощным и в то же время
простым инстурментом, обладают одним фундаментальным ограничением:
они не могут распознавать рекурсивные структуры.

Однако, языки программирования в большинстве случаев требуют
возможности определять рекурсивные элементы, типа вложенных блоков
или подвыражений.

Анализ и классификаци формальных языков, проведенные Ноамом
Чомским, поместили регулярные языки на нижний уровень в
одноименной иерархии. Однако на уровне выже расположились
\textit{контестно-свободные языки}, которые обладают достаточными
возможностями для распознавания рекурсивных элементов, что делает
их рабочей лошадкой синтаксических анализаторов для большинства
языков программирования.

Формально, контестно свободная грамматика определяется как
четверака $G = (V, \Sigma, R, S)$, где

\begin{enumerate}
	\item $V$ --- это конечное множество. Каждый элемент $v \in V$
		называют \textit{нетерминальным символом} или
		\textit{переменной}. Иногда их также называют
		\textit{синтаксическими категориями}. Каждая переменная
		определяет дочерний язык языка, определяемого $G$.
	\item $\Sigma$ --- это конечное множество $терминалов$,
		непересекающийся с $V$. Множество терминалов определяет
		алфавит языка, определенного грамматикой $G$.
	\item $R$ --- это конечное отношение в $V \times (V \cup
		\Sigma)^*$. Элементы множества $R$ называют \textit{правилами}
		или \textit{продукциями} грамматики.
	\item $S$ --- это начальная переменная, используемый для
		представления всего предложения.
\end{enumerate}

Задача распознавания потока символов контекстно-свободной
грамматикой и называется парсингом. Эта проблема хорошо изучена и
существует ряд классических и провереных алгоритмов парсинга.
Невдаваясь в подробности, остановимся на одном из самых простых и
эффективных методах парсинга --- \textit{рекурсивном спуске}.

Рекурсивный спуск это подвид нисходящих парсеров в котором каждая
процедура реализует один из нетерминальных символов грамматики.
Таким образом структура реализации такого парсера повторяет
структуру самой грамматики, которую этот парсер распознает.

Предиктивный рекурсивный спуск не требует бэктрекинга. Таким
парсеры возможны только для LL(k) грамматик, которые являтются
контекстно-свободными грамматиками, для которых существует
положительное целое $k$, которое позволяет парсеру определить
какую продукцию использовать просмотрев только $k$ следующих
токенов. Таким образом, LL(k) грамматики исключают все
неоднозначные грамматики, а также все леворекурсивные грамматики.

Рекурсивный спуск с бектрекингом это техника, при которой парсер
определяет подходящую продукцию, пробуя все продукции подряд и
делая возврат к предыдущему состоянию при ошибке. Такой парсер не
ограничивается LL(k) грамматикам, но не может гарантировать
завершение работы, если только грамматика не является LL(k).

\subsubsection{Построение абстрактного синтаксического дерева}

Конкретное синтаксическое дерево полностью совпадает с грамматикой
языка. К сожалению, получаемое в процессе парсинга дерево выходит
слишком большим и ``зашумленными'' и не может быть эффективно
использовано для дальнейшего анализа программы. Например, деревья
разбора обычно сохраняют в себе такие незначимые для дальнейшего
процесса компиляции детали как узлы пунктуационных элементов типа
фигурных скобок, точек с запятой и прочих.

% TODO: написать про проблему обратной логики деклараций в C.
% https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees

Для решения этой проблемы было придумано такое представление
программы как \textit{абстрактное синтаксическое дерево} (англ.
\textit{AST}). Такие деревья получаются гораздо меньшего размера и
таким образом, с ним проще работать в дальнейших стадиях
компиляции.

Превращение AST в CST является крайне нетривиальной задачей и
каких конкретных устоявшихся алгоритмов для ее решения нет.

Существует такой язык как ASDL, который используется для
декларативного описания узлов абстрактного синтаксического дерева
и дальнейшей генерации кода для разных языков, который эти узлы
описывает. Однако он служит исключительно в целях описания
структуры AST, а не конвертации CST в AST.

Из-за этой проблемы парсеры обычно генерируют сразу AST дерево,
минуя этап формирования отдельного CST. Однако нам этот метод не
подходит, потому что нам необходимо иметь возможность интроспекции
как CST, так и AST.

Таким образом, единственным вариантом для нас остается так
называемый метод ноу-хау, в котором мы будем в ручную проходить по
CST дереву и строить соответствующие узлы AST. Такой же подход
использует компилятор Groovy~\cite{joesgroovy}.

\subsubsection{Кодогенерация}

Кодогенерация является последним этапом процесса компиляции и
представляет собой генерацию кода на выходном языке, который может
быть напрямую исполнен целевой платформой, из некоторого
промежуточного представления.

В нашем случае, мы будем генерировать ассемблерный код под
архитектуру Intel 64 с System V ABI в синтаксисе AT\&T напрямую из
AST.

\subsection{Проектирование системы}

\subsubsection{Определение информационных потоков системы}

Перед стадией разработки на этапе проектирования необходимо
определить информационные потоки системы. Информационные потоки
помогут лучше понять через какие этапы проходят основные процессы,
которые были подвержены автоматизации, какие данные используются и
что получает на выходе пользователь системы.

На сегодняшний день одним из удобных и популярных способов
представления информационных потоков являются IDEF диаграммы. IDEF
диаграммы --- это методология для решения моделирования сложных
систем, данные диаграммы позволяют отображать и анализировать
различные процессы или деятельность пользователей системы в
различных разрезах. Широту и глубину обследования процессов
определяет сам разработчик, благодаря знаниям и опыту которого
создаваемая модель не перегружается излишними процессами и
информацией.

Для построения высокоуровневой модели системы необходимо создать
диаграмму IDEF0. Данная диаграмма предполагает наличие четко
сформулированной цели единственного субъекта моделирования и одной
точки зрения, она поможет более точно выявить главные процессы в
системе. На диаграмме указывают какие данные поддаются на вход,
какие данные получает пользователь в результате данного процесса,
какие модули и компоненты программного обеспечения принимают в
этом участие.

IDEF0 является методологией функционального моделирования. Она
используется для создания функциональной модели, которая
отображает структуру и функции системы, а также потоки информации
и материальных объектов, связывающих эти функции. Компонентами
синтаксиса IDEF0 являются блоки, стрелки, диаграммы и правила.

Диаграмма IDEF0 состоит из \obj{блоков} и \obj{стрелок},
направление которых заданы правила. Блоки изображаются в виде
прямоугольников и содержат в себе описание той функции, которую
они представляют, и номер. Номер блока должен быть расположен в
правом нижнем углу.

К каждому блоку должно вести несколько стрелок, такие как:

\begin{itemize}
	\item \obj{левые стрелки} (направлены в блок) обозначают
		информацию или продукты, которую функция получает на входе;

	\item \obj{правые стрелки} (направлены из блока) обозначают
		информацию или продукты, которую функция дает на выходе;

	\item \obj{верхние стрелки} (направлены в блок) обозначают
		документы, которые регламентируют работы системы;

	\item \obj{нижние левые стрелки} (направлены в блок) обозначают
		механизмы, которые влияют на работу нашей системы;

	\item \obj{нижние правые стрелки} (направлены из блока)
		обозначают обращение к дополнительной информационной системе,
		которая существует совершенно отдельно от нашей и которая
		необходима для осуществления процесса или функции. Может как
		присутствовать на схеме, так и нет.
\end{itemize}

На рисунке ниже представлена диаграмма IDEF0 процесса компиляции
одной единицы трансляции.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth,clip=true]{img/IDEF-0.png}
	\caption{Комплексная диаграмма IDEF0 процесса компиляции единицы
	трансляции.}
\end{figure}

Также на этапе проектирования полезно сделать более детальную
декомпозицию комплексной диграммы IDEF0, что позволяет более
подробно рассмотреть структуру и функции изучаемой системы.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth,clip=true]{img/IDEF-1.png}
	\caption{Декомпозиця комплексной диаграммы IDEF0.}
\end{figure}

\subsubsection{Описание системных процессов}

Методология IDEF3 --- это методология описания процессов. В
отличие от IDEF0 она рассматривает последовательность выполнения
задач, а также причинно-следственные связи между ними. Диаграммы
IDEF3 состоят из блоков, описывающих функции, стрелок-связей и
перекрёстков, которые показывают, как именно выполняются процессы.

\obj{Блок} (функциональный элемент) представляет собой
прямоугольник, разделенный на три другие прямоугольника: один
большой наверху и два маленьких друг рядом с другом внизу. В
верхнем прямоугольнике содержится имя функции, в нижнем левом
номер его выполнения, в нижнем правом, при необходимости,
находится ссылка на другую функцию. Связи бывают простыми,
относительными и связями с условием.

Перекрёстки подразделяются на следующие типы: \obj{И}, \obj{ИЛИ},
\obj{синхронное И}, \obj{синхронное ИЛИ}, а также \obj{исключающее
ИЛИ}.

\begin{sidewaysfigure}
	\centering
	\includegraphics[width=\textwidth,clip=true]{img/IDEF3.png}
	\caption{Диаграмма описания процессов по методологии IDEF3.}
\end{sidewaysfigure}

\subsubsection{Описание потоков данных}

\term{Диаграммы потоков данных} (англ. \term{DFD}) --- это способ
представления процессов обработки информации. Они показывают, как
информация перемещается из одной функции к другой. Подобное
представление потока данных отражает движение объектов, их
хранение и распространение.

DFD состоит из следующих компонентов: внешняя сущность, процесс,
поток данных и хранилище данных~\cite{dfd}. Внешняя сущность
представляет собой источник или приёмник информации и изображается
прямоугольником с прямыми углами. Процессы в DFD --- это функции
системы, преобразующие входы и выходы, которые изображаются как
прямоугольники со скругленными углами. Потоки данных изображаются
стрелками. Если стрелка соединяет какую-либо функцию с хранилищем
данных, то на ней должно быть отображено имя, отражающее
содержание данного потока. Хранилище данных является прообразом
базы данных и изображается как прямоугольник без правой стороны.

\begin{figure}[H]
	\centering
	\includegraphics[height=0.8\textwidth,keepaspectratio,clip=true]{img/DFD.png}
	\caption{Описание потоков данных по методологии DFD.}
\end{figure}

\subsubsection{Описание пакетов системы}

\term{Диаграмма пакетов} --- это структурная диаграмма UML,
которая показывает структуру проектируемой системы на уровне
пакетов~\cite{martin}. Обычно на диаграмме изображаются следующие
элементы: пакет, пакетированный элемент, зависимость,
импортируемый элемент, импорт пакета, объединение пакета.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth,clip=true]{img/UML-package.png}
	\caption{Диаграмма описания пакетов системы по методологии UML.}
\end{figure}

\subsubsection{Описание компонентов}

\term{Диаграмма компонентов} показывает компоненты,
предоставляемые и требуемые интерфейсы, порты и отношения между
ними~\cite{buch}. Этот тип диаграмм используется в
компонентно-ориентированной разработке для описания систем с
сервисно-ориентированной архитектурой~\cite{douglass}.

Компонентно-ориентированная разработка основана на предположения,
что ранее сконструированные компоненты могут быть переиспользованы
или, при необходимости, заменены на некие \enquote{эквивалентные}
или \enquote{совместимые} компоненты.

\begin{sidewaysfigure}
	\centering
	\includegraphics[width=\textwidth,clip=true]{img/UML-components.png}
	\caption{Диаграмма описания компонентов, выполненная по
	методологии UML.}
\end{sidewaysfigure}

\subsubsection{Описание потоков информации по UML}

\term{Диаграмма потока информации} --- это поведенческая диаграмма
UML, которая показывает обмен информацией между сущностями системы
на высоком уровне абстракции. Потоки информации могут быть полезны
для описания циркуляции информации через систему через
представление аспектов модели, которые еще не полностью
специфицированы или недостаточно детализированы.

Потоки информации не показывают природу информации, механизмы
передачи, порядок обмена или какие-либо контрольные условия~
\cite{penker}. Единицы информации могут быть использованы для
представления информации, которая протекает через систему вместе с
информационными потоками еще прежде, чем их реализация будет
проработана.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth,clip=true]{img/UML-information-flow.png}
	\caption{Описание потоков информации системы с помощью диаграммы
	потока информации методологии UML.}
\end{figure}

\pagebreak
\section{Описание практической реализации}

\subsection{Компилятор}

В качестве средств для разработки компилятора были выбраны
инструменты из экосистемы GNU/Linux.

\subsubsection{Система сборки}

В качестве системы сборки есть три наиболее распространенных
решения: GNU Make, CMake и GNU Autotools.

\paragraph{GNU Make}

В настоящее время существует множество утилит для сборки с
отслеживанием зависимостей, но Make является одной из самых
распространенных, в первую очередь благодаря тому, что она была
включена в Unix, начиная с PWB/UNIX 1.0, в которой было множество
инструментов, предназначенных для задач разработки программного
обеспечения. Первоначально он был создан Стюартом Фельдманом в
апреле 1976 года в Bell Labs. Фельдман получил награду ACM
Software System Award 2003 года за создание этого широко
распространенного инструмента.

Make обычно используется для сборки исполняемых программ и
библиотек из исходного кода. Однако в целом Make применим к любому
процессу, который включает выполнение произвольных команд для
преобразования исходного файла в конечный результат. Например,
Make можно использовать для обнаружения изменений, внесенных в
файл изображения (источник), а действия по преобразованию могут
заключаться в преобразовании файла в определенный формат,
копировании результата в систему управления контентом, а затем
отправке электронной почты заранее определенному набору
пользователей с указанием того, что вышеуказанные действия были
выполнены.

Среди ключевых достоинств GNU Make можно выделить:

\begin{itemize}
	\item Широкая распространенность и повсеместное использование.
	\item Проста и логичность написания правил сборки.
	\item Универсальность, позволяющая собирать произвольные
		артефакты, а не только исполняемые файлы.
\end{itemize}

Из недостатоков можно отметить:

\begin{itemize}
	\item Не предусмотрена автоматическая пересборка файлов
		исходного кода при изменении заголовочных файлов, что требует
		дополнительной логики в Makefile.
	\item В больших проектах Makefile очень быстро становится сложно
		сопровождать.
\end{itemize}

\paragraph{CMake}

CMake --- это кроссплатформенное бесплатное программное
обеспечение с открытым исходным кодом для автоматизации сборки,
тестирования, упаковки и установки программного обеспечения с
помощью независимого от компилятора метода. CMake не является
системой сборки, а скорее генерирует файлы сборки другой системы.
Он поддерживает иерархии каталогов и приложения, зависящие от
множества библиотек. Он используется совместно с родными средами
сборки, такими как Make, Qt Creator, Ninja, Android Studio,
Apple's Xcode и Microsoft Visual Studio. Он имеет минимальные
зависимости, требуя только компилятор C++ в собственной системе
сборки.

Сборка программы или библиотеки с помощью CMake представляет собой
двухэтапный процесс. Сначала из конфигурационных файлов
(\texttt{CMakeLists.txt}), написанных на языке CMake, создаются
(генерируются) стандартные файлы сборки. Затем используются
встроенные инструменты сборки платформы (т.н. \textit{native
toolchain}) для фактической сборки программ.

Файлы сборки конфигурируются в зависимости от используемого
генератора (например, \textit{Unix Makefiles} для make). Опытные
пользователи могут также создавать и включать дополнительные
генераторы Makefile для поддержки своих специфических потребностей
в компиляторе и ОС. Сгенерированные файлы обычно помещаются (с
помощью флага \texttt{cmake} в папку вне исходника (сборка вне
исходника), например, \texttt{build/}.

Каждый проект сборки в свою очередь содержит свой собственный файл
\texttt{CMakeCache.txt} и каталог \texttt{CMakeFiles} в каждом
(под)каталоге проекта, включаемом командой
\texttt{add\_subdirectory(...)}, что помогает избежать или
ускорить регенерацию при многократном запуске.

После создания Makefile (или альтернативного) поведение сборки
может быть точно настроено через свойства цели или через
глобальные переменные \texttt{CMAKE\_...}-префикс. Последнее не
рекомендуется для конфигураций только для целей, поскольку
переменные также используются для конфигурирования самого CMake и
установки начальных значений по умолчанию.

Из преимуществ CMake можно выделить:

\begin{itemize}
	\item Кроссплатформенность и интеграция с IDE.
\end{itemize}

Из недостатков:

\begin{itemize}
	\item Двухступенчатый процесс сборки, который может быть
		непривычен и непонятен студентам.
	\item Зависимость от вторичной системы сборки.
\end{itemize}

\paragraph{GNU Autotools}

GNU Autotools, также известный как GNU Build System, --- это набор
инструментов программирования, предназначенный для помощи в
создании пакетов исходного кода, переносимых на многие
Unix-подобные системы.

Сделать программу переносимой может быть непросто: компилятор C
отличается от системы к системе; некоторые библиотечные функции
отсутствуют в некоторых системах; заголовочные файлы могут иметь
разные имена. Одним из способов решения этой проблемы является
написание условного кода с выделением блоков кода с помощью
директив препроцессора (\texttt{\#ifdef}); но из-за большого
разнообразия сред сборки такой подход быстро становится
неуправляемым. Autotools предназначен для более удобного решения
этой проблемы.

Autotools является частью набора инструментов GNU и широко
используется во многих пакетах свободных программ и пакетов с
открытым исходным кодом. Его составные инструменты являются
свободным программным обеспечением, лицензируемым по лицензии GNU
General Public License со специальными лицензионными исключениями,
позволяющими использовать его с несвободным программным
обеспечением.

К преимуществам GNU Autotools относят:

\begin{itemize}
	\item Гибкость при конфигурации программного обеспечения под
		различные платформы.
	\item Широкая распространенность в экосистеме GNU/Linux.
\end{itemize}

Однако GNU Autotools не раз сталкивался с резкой критикой, которая
в основом отмечает сложность и запутанность процесса сборки.

\paragraph{Сравнение}

Поскольку мы делаем большой фокус на простоту и элегантность
проекта, наилучшим выбором для нас станет использование GNU Make.

\subsubsection{Лексический анализ}

Модуль лексического анализатора пользуется встроенной в GNU C
Library реализацией регулярных выражений.

В исходном коде мы в декларативном стиле определяем список
токенов, а также соответствующие им регулярные выражения. Для
того, чтобы избежать дублирования кода мы используем классическую
технику X Macro.

При вызове основной процедуры лексера \texttt{tokenize()} мы
начинаем проходить по строке исходного кода символ за символом и
пытаться распознать следующий токен последовательно с помощью
каждого регулярного выражения.

В конце концов, если одно из выражений удается распознать мы
создаем новый токен с соответствующим типом и записываем
информацию о лексеме, полученную с помощью инструмента групп
захвата регулярных выражений.

Таким образом мы распознаем весь поток символов и превращаем его в
поток токенов.

В случае, если на определенном этапе анализа, нам не удалось
распознать оставшийся поток символов ни одним из регулярных
выражений, мы возвращаем ошибку, сигнализирующую о лексической
ошибке ввода.

\subsubsection{Синтаксический анализ}

Для синтаксического анализа мы используем алгоритм рекурсивного
спуска. Однако, вместо того чтобы вручную писать парсер, было
принято решения создать небольшой генератор парсеров, который мог
бы самостоятельно генерировать код рекурсивного спуска из
переданного ему декларативного описания грамматики.

Мы описываем грамматику, используя похожий на EBNF синтаксис. В
процессе сборки, генератор парсера преобразует это описание в
исходный файл на языке C с соответствующими процедурами,
распознающими нетреминальный символы.

Далее этот сгенерированный парсер линкуется вместе со всеми
остальными модулями компилятора.

Сам парсер начинает распознавания потока токенов, рассматривая его
к единицу трансляции. Далее он пытается распознать оставшийся
поток токенов по-очередно с помощью каждой продукции. В случае,
если продукция не была распознана, выполняется бэктрекинг, который
возвращает курсор парсера на прежнее место в потоке токенов.

В случае успешного распознавания потока токенов, парсер возвращает
конкретное синтаксическое дерево, которое хранит информацию о
синтаксический и лексических единицах, а также о положении каждого
токена в исходном коде.

В случае неудачного распознавания нетерминального символа парсер
возвращает ошибку, сигнализирующую о синтаксической ошибке.
Отдельным видом такой ошибки является неожиданный конец ввода.

\subsubsection{Построение абстрактного синтаксического дерева}

Следующим этапом мы проходим по конкретному синтаксическому
дереву, полученному от парсера и пытаемся построить AST.
Все происходит полностью в ручном процессе.

На этом этапе мы пытаемся определить типы идентификаторов в их
объявлениях, их спецификаторы типов, типы выражений и прочее.
Иными словами, заполнить атрибуты в соответствующих описаниях
узлов AST.

Каждый узел AST представляет из себя структуру \texttt{struct ast},
которая состоит из объединения и поля члена перечисления.
Объединение содержит структуры конкретных типов AST узлов,
например \texttt{struct ast\_transunit} или \texttt{struct
ast\_parmdecl}. Какой конкретно элемент объединения выбран в
данный момент определяет поле \texttt{kind} обобщенной структуры.

В некоторых случаях, из CST не может быть построенно AST, потому
что в исходном коде присутствовала семантическая ошибка. В таком
случае генератора AST вовзращает встреченную ошибку с подробным
описанием.

Рассмотрим пример, когда во входном коде присутствует конструкция

\begin{verbatim}
signed unsigned int a;
\end{verbatim}

которая является абсолютно корректной с синтаксической точки
зрения. С точки зрения семантики она является ошибочной так как
стандарт языка прямо запрещает подобную комбинацию спецификаторов
типа.

В таком случае генератор AST вернет вызывающей стороне ошибку с
кодом \texttt{C2A\_ERR\_BAD\_TYPE\_SPECIFIERS}.

\subsubsection{Кодогенерация}

\subsubsection{Интерфейс командной строки}

Компилятор предоставляет интерфейс командной строки (англ.
\textit{CLI}). Пользователь должен передать компилятору ключ
соответствующий предствлению кода, которое он хочет получить
(например, \texttt{-ast} и \texttt{-cst} для абстрактного и
конкретного синтаксических деревьев соответственно). Также
опционально может быть передан флаг \texttt{-json}, который
указывает компилятору на то, что вывод должен быть представлен в
формате JSON.

Следующим образом выглядят различные промежуточные представления,
полученные от компилятора:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_lex.png}
	\caption{Результат работы лексического анализа. Можно видеть
	поток получившихся токенов, их лексемы и позицию в исходном коде
	(соответствующие строка и столбец).}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_cst.png}
	\caption{Результат работы парсера в CLI представляет из себя
	визуализированное дерево разбора.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_ast.png}
	\caption{Построенное из дерева разбора AST.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_codegen.png}
	\caption{Сгенерированный ассемблерный код.}
\end{figure}

\subsubsection{Экспорт промежуточных представлений в формате JSON}

Для того дальнейшней обработки результатов интроспекции различных
представлений кода, в компиляторе предусмотрена возможность
экспорта вывода в формате JSON. За эту опцию отвечает флаг
\texttt{--json} в CLI. Ниже на рисунках показан экспорт в JSON
различных представлений кода.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_lex_json.png}
	\caption{Экспорт в JSON потока токенов, полученного от
	лексического анализатора.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_cst_json.png}
	\caption{Экспорт в JSON дерева разбора, полученного от
	синтаксического анализатора.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_ast_json.png}
	\caption{Экспорт в JSON построенного AST.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{img/cli_codegen_json.png}
	\caption{Экспорт в JSON сгенерированного ассебмлерного кода.}
\end{figure}

\subsection{Серверная часть}

Серверная часть веб-приложения для компилятора работает следующим
образом. Сервер предоставляет открытое API с несколькими
эндпоинтами, каждый из которых позволяет получить одно из
промежуточных представлений кода. Когда пользователь делает запрос
к сайту, веб-сервер прислает ему статические файлы клиентского
кода, которые делают асинхронные AJAX запросы к вышеупомянутому
API.

В качестве веб-сервера был выбран Nginx как один из самых
популярных и легко конфигурируемых. В качестве языка для написания
бекенда был выбран язык Go, так как он позволяет максимально
быстро и просто создавать серверные приложения. Ниже немного
расскажем про каждую из этих технологий и конкретную логику их
работы в нашем случае.

\subsubsection{Nginx}

Nginx, произносится как ``engine X'', является веб-сервером с
открытым исходным кодом, который, после своего первоначального
успеха в качестве веб-сервера, теперь также используется в
качестве обратного прокси, HTTP-кэша и балансировщика нагрузки.

Некоторые известные компании, использующие Nginx, включают
Autodesk, Atlassian, Intuit, T-Mobile, GitLab, DuckDuckGo,
Microsoft, IBM, Google, Adobe, Salesforce, VMWare, Xerox,
LinkedIn, Cisco, Facebook, Target, Citrix Systems, Twitter, Apple,
Intel и многие другие.

Nginx был первоначально создан Игорем Сысоевым, его первый
публичный релиз состоялся в октябре 2004 года. Игорь изначально
задумывал программное обеспечение как ответ на проблему C10k,
которая связана с проблемой производительности при обработке 10
000 одновременных соединений.

Поскольку его корни лежат в оптимизации производительности при
масштабировании, Nginx часто превосходит другие популярные
веб-серверы в эталонных тестах, особенно в ситуациях со
статическим контентом и/или большим количеством одновременных
запросов.

Мы используем Nginx для раздачи статических файлов фронтенда
веб-приложения. Однако все запросы на эндпоинты \texttt{/codegen},
\texttt{/genast}, \texttt{/tokenize} и \texttt{/parse}
проксируются на слушающий на локальном хосте бекенд, который
предоставляет API компилятора.

\subsubsection{Go}

Go --- это компилируемый язык с открытым исходным кодом и сильной
типизацией, написанный для создания параллельного и
масштабируемого программного обеспечения. Язык был изобретен в
Google Робом Пайком, Кеном Томсоном и Робертом Гризмером. Go
предназначен для создания простого, надежного и эффективного
программного обеспечения.

Go был разработан в Google в 2007 году для повышения
производительности программирования в эпоху многоядерных, сетевых
машин и больших кодовых баз. Разработчики хотели снять критику с
других языков, используемых в Google, но сохранить их полезные
характеристики:

\begin{enumerate}
	\item Статическая типизация и эффективность во время выполнения
		(как C).
	\item удобочитаемость и удобство использования (как Python или
		JavaScript).
	\item Высокопроизводительные сети и многопроцессорность.
\end{enumerate}

Его разработчики были в первую очередь мотивированы их общей
неприязнью к C++.

Go был публично анонсирован в ноябре 2009 года, а версия 1.0 была
выпущена в марте 2012 года. Go широко используется в производстве
в Google и во многих других организациях и проектах с открытым
исходным кодом.

В ноябре 2016 года шрифты Go и Go Mono были выпущены шрифтовыми
дизайнерами Чарльзом Бигелоу и Крисом Холмсом специально для
использования в проекте Go. Go --- гуманистический сансериф,
напоминающий Lucida Grande, а Go Mono --- моноширинный. Оба шрифта
соответствуют набору символов WGL4 и были разработаны так, чтобы
быть разборчивыми с большой высотой x и четкими формами букв. И
Go, и Go Mono соответствуют стандарту DIN 1450, поскольку имеют
косой ноль, строчную l с хвостиком и прописную I с засечками.

В апреле 2018 года оригинальный логотип был заменен стилизованным
GO, наклоненным вправо с обтекаемыми линиями. (Талисман суслика
остался прежним).

Наш бекенд, написанный на Go, работает следующим образом. При
запуске процесса мы создаем встроенный в стандартную библиотеку
языка веб-сервер, который принимает запросы на такие эндпоинты как
\texttt{/codegen}, \texttt{/genast}, \texttt{/tokenize} и
\texttt{/parse}.

При получении запроса на эндпоинт, мы запускаем в дочернем
процессе наш компилятор с соответствующими флагами и передаем ему
полученный при запросе исходный код. Компилятор возвращает бекенду
ответ в формате JSON, который бекенд затем пересылает клиенту в
качестве ответа.

\subsubsection{JSON}

JSON --- это открытый стандартный формат файлов и формат обмена
данными, который использует человекочитаемый текст для хранения и
передачи объектов данных, состоящих из пар атрибут-значение и
массивов (или других сериализуемых значений). Это распространенный
формат данных, который находит разнообразное применение в
электронном обмене данными, в том числе при взаимодействии
веб-приложений с серверами.

JSON --- это независимый от языка формат данных. Он был
заимствован из JavaScript, но многие современные языки
программирования включают код для генерации и разбора данных в
формате JSON. В именах файлов JSON используется расширение
\texttt{.json}.

JSON вырос из потребности в протоколе связи между сервером и
браузером в режиме реального времени без использования плагинов
браузера, таких как Flash или Java-апплеты, которые доминировали в
начале 2000-х годов.

Предшественник библиотек JSON был использован в детском игровом
проекте по торговле цифровыми активами под названием Cartoon Orbit
на Communities.com (где ранее работали все соучредители State
Software) для Cartoon Network, который использовал плагин для
браузера с собственным форматом обмена сообщениями для
манипулирования элементами Dynamic HTML (эта система также
принадлежит 3DO). После открытия ранних возможностей AJAX,
digiGroups, Noosh и другие использовали фреймы для передачи
информации в визуальное поле браузера пользователя без обновления
визуального контекста веб-приложения, реализуя богатые
веб-приложения в реальном времени, используя только стандартные
возможности HTTP, HTML и JavaScript в Netscape 4.0.5+ и IE 5+.

Крокфорд впервые определил и популяризировал формат JSON.
Соучредители State Software согласились создать систему,
использующую стандартные возможности браузеров и обеспечивающую
уровень абстракции для веб-разработчиков, позволяющий создавать
веб-приложения с состоянием, которые имеют постоянное дуплексное
соединение с веб-сервером, удерживая два открытых соединения по
протоколу передачи гипертекста (HTTP) и утилизируя их до истечения
стандартного времени браузера, если обмен данными не происходит.
Соучредители провели круглый стол и проголосовали за то, как
назвать формат данных --- JSML (JavaScript Markup Language) или
JSON (JavaScript Object Notation), а также под каким типом
лицензии сделать его доступным. Чип Морнингстар разработал идею
State Application Framework в компании State Software.

JSON в основном предназначен для обмена данными между
приложениями. Парсинг данных из одного приложения в другое с
помощью JSON очень прост благодаря его независимому от языка
формату данных. Почти каждый язык программирования имеет поддержку
JSON через официальные и сторонние разработчики. Теперь, ссылаясь
на мой пример, JSON можно использовать как файл конфигурации или
временного хранения данных для любого приложения. Существует
важный факт, что JSON не имеет функции абстрактного типа данных
(ADT) из-за своего формата сериализации данных, который нарушает
непрозрачность ADT, потенциально раскрывая частные детали
реализации.

\subsection{Графический интерфейс компилятора}

\subsubsection{Выбор средств разработки}

Для разработки веб-интерфейса для компилятора было принято решение
использовать классические технологии создания веб-страниц HTML,
CSS и JavaScript.

\paragraph{HTML}
Язык разметки гипертекста или HTML --- это стандартный язык
разметки для документов, предназначенных для отображения в
веб-браузере. Ему могут помогать такие технологии, как каскадные
таблицы стилей (CSS) и языки сценариев, такие как JavaScript.

Веб-браузеры получают HTML-документы с веб-сервера или из
локального хранилища и отображают документы в виде мультимедийных
веб-страниц. HTML описывает структуру веб-страницы семантически и
изначально включал подсказки для внешнего вида документа.

HTML-элементы --- это строительные блоки HTML-страниц. С помощью
HTML-конструкций изображения и другие объекты, такие как
интерактивные формы, могут быть встроены в отображаемую страницу.
HTML предоставляет средства для создания структурированных
документов, обозначая структурную семантику для текста, такого как
заголовки, абзацы, списки, ссылки, цитаты и другие элементы.
Элементы HTML обозначаются тегами, написанными с использованием
угловых скобок. Такие теги, как \texttt{<img />} и \texttt{<input
/>}, непосредственно вводят содержимое на страницу. Другие теги,
такие как \texttt{<p>}, окружают и предоставляют информацию о
тексте документа и могут включать другие теги в качестве
подэлементов. Браузеры не отображают HTML-теги, но используют их
для интерпретации содержимого страницы.

HTML может встраивать программы, написанные на языке сценариев,
таком как JavaScript, который влияет на поведение и содержание
веб-страниц. Включение CSS определяет внешний вид и расположение
контента. Консорциум Всемирной паутины (W3C), бывший разработчик
стандартов HTML и нынешний разработчик стандартов CSS, поощряет
использование CSS вместо явного представления HTML с 1997 года.
Форма HTML, известная как HTML5, используется для отображения
видео и аудио, в основном с использованием элемента
\texttt{<canvas>} в сотрудничестве с JavaScript.

\paragraph{CSS}

Каскадные таблицы стилей (CSS) --- это язык таблиц стилей,
используемый для описания представления документа, написанного на
языке разметки, таком как HTML. CSS является краеугольным камнем
технологии World Wide Web, наряду с HTML и JavaScript.

CSS разработан для разделения представления и содержания, включая
макет, цвета и шрифты. Такое разделение может улучшить доступность
содержания; обеспечить большую гибкость и контроль при определении
характеристик представления; позволить нескольким веб-страницам
совместно использовать форматирование путем указания
соответствующего CSS в отдельном \texttt{.css} файле, что
уменьшает сложность и повторение структурного содержания; и
позволить кэшировать \texttt{.css} файл для улучшения скорости
загрузки страницы между страницами, которые совместно используют
этот файл и его форматирование.

Разделение форматирования и содержимого также позволяет
представить одну и ту же страницу разметки в разных стилях для
различных методов визуализации, например, на экране, в печати,
голосом (через речевой браузер или программу чтения с экрана) и на
тактильных устройствах на основе шрифта Брайля. В CSS также есть
правила для альтернативного форматирования, если контент доступен
на мобильном устройстве.

Название ``каскадный'' происходит от указанной схемы приоритетов
для определения того, какое правило стиля применяется, если
определенному элементу соответствует более одного правила. Эта
каскадная схема приоритетов предсказуема.

\paragraph{JavaScript}

JavaScript, часто сокращенно JS, --- это язык программирования,
который является одной из основных технологий Всемирной паутины,
наряду с HTML и CSS. Более 97\% веб-сайтов используют JavaScript
на стороне клиента для поведения веб-страниц, часто используя
сторонние библиотеки. Все основные веб-браузеры имеют специальный
движок JavaScript для выполнения кода на устройствах
пользователей.

JavaScript --- это высокоуровневый, часто компилируемый язык,
соответствующий стандарту ECMAScript. Он имеет динамическую
типизацию, объектную ориентацию на основе прототипов и функции
первого класса. Это мультипарадигма, поддерживающая
событийно-управляемый, функциональный и императивный стили
программирования. Он имеет интерфейсы прикладного программирования
(API) для работы с текстом, датами, регулярными выражениями,
стандартными структурами данных и объектной моделью документа
(DOM).

Стандарт ECMAScript не включает никаких средств ввода/вывода
(I/O), таких как сетевые средства, средства хранения данных или
графические средства. На практике веб-браузер или другая система
выполнения предоставляет API JavaScript для ввода/вывода.

Движки JavaScript первоначально использовались только в
веб-браузерах, но сейчас являются основными компонентами некоторых
серверов и разнообразных приложений. Наиболее популярной системой
выполнения для такого использования является Node.js.

\paragraph{jQuery}

jQuery --- это библиотека JavaScript, предназначенная для упрощения
обхода и манипулирования деревом DOM HTML, а также обработки
событий, CSS-анимации и AJAX. Это бесплатное программное
обеспечение с открытым исходным кодом, использующее разрешительную
лицензию MIT. По состоянию на май 2019 года, jQuery
используется 73\% из 10 миллионов самых популярных веб-сайтов.
Веб-анализ показывает, что это самая широко используемая
библиотека JavaScript с большим отрывом, по крайней мере, в 3-4
раза больше, чем любая другая библиотека JavaScript.

Синтаксис jQuery разработан для облегчения навигации по документу,
выбора элементов DOM, создания анимации, обработки событий и
разработки приложений AJAX. jQuery также предоставляет
разработчикам возможность создавать подключаемые модули поверх
библиотеки JavaScript. Это позволяет разработчикам создавать
абстракции для низкоуровневого взаимодействия и анимации,
продвинутых эффектов и высокоуровневых, тематически настраиваемых
виджетов. Модульный подход к библиотеке jQuery позволяет создавать
мощные динамические веб-страницы и веб-приложения.

Набор основных функций jQuery --- выбор, обход и манипулирование
элементами DOM - поддерживаемый его селекторным движком (названным
``Sizzle'' с версии 1.3), создал новый ``стиль программирования'',
объединяющий алгоритмы и структуры данных DOM. Этот стиль повлиял
на архитектуру других JavaScript-фреймворков, таких как YUI v3 и
Dojo, позже стимулировав создание стандартного API Selectors.

Microsoft и Nokia поставляют jQuery на свои платформы. Microsoft
включает его в Visual Studio для использования в рамках
фреймворков Microsoft ASP.NET AJAX и ASP.NET MVC, а Nokia
интегрировала его в платформу разработки виджетов Web Run-Time.

\paragraph{DarkReader}

DarkReader --- это расширение для браузера, которое позволяет с
легкостью превращать любые сайты в сайты с темной темой, которая
гораздо меньше напрягает глаза при длительном простмотре
веб-страниц.

Темный режим --- это дополнительный режим, который можно
использовать для отображения в пользовательском интерфейсе
преимущественно темных поверхностей. Он позволяет снизить уровень
света, излучаемого экранами устройств, сохраняя при этом
минимальные коэффициенты цветовой контрастности, необходимые для
удобства чтения. Преимущества темного режима заключаются в том,
что он улучшает визуальную эргономику, снижая напряжение глаз,
облегчая настройку экранов в соответствии с текущими условиями
освещенности и обеспечивая комфорт использования ночью или в
темной обстановке.

Кроме того, он экономит заряд батареи, позволяя использовать
устройство в течение длительного времени без подзарядки. Обычно
темную тему можно выключить или включить с помощью заметного
значка-переключателя на экране. Кроме того, он размещается в меню
или в настройках приложения.

Мы используем это расширение в формате библиотеки JavaScript для
нашего сайта, чтобы обеспечить пользователям более приятный опыт
использования.

\paragraph{Resizable.js}

Resizable.js --- это JavaScript библиотека, которая позволяет
создавать блочные элементы веб-страницы с изменяемыми с помощью
курсора мыши размерами.

Эта библиотека позволит пользователям настраивать экраны
приложения нужным им образом, фокусируя внимания на том или ином
промежуточном представлении кода.

\paragraph{CodeMirror}

CodeMirror --- библиотека на языке JavaScript, предоставляющий
редактор кода в браузере с открытым исходным кодом, доступный под
лицензия MIT. Работает в таких браузерах и программах как:
Firefox, Chrome, и Safari, a также Light Table, Adobe Brackets,
Bitbucket, и многих других проектах. CodeMirror имеет богатый
программный API и ориентирован на расширяемость.

Первая версия редактора была написана в начале 2007 года для
консоли веб-сайта Eloquent JavaScript. Код был впервые собран и
выпущен под названием CodeMirror в мае 2007 года. Эта версия была
основана на такой функциональной возможности браузеров как атрибут
\texttt{contentEditable}. Это перечисляемый атрибут, указывающий,
должен ли элемент редактироваться пользователем. Если это так,
браузер изменит свой виджет, чтобы разрешить редактирование.

В конце 2010 года Ace, еще один редактор кода на основе
JavaScript, впервые применил новые методы реализации и
продемонстрировал, что даже в JavaScript можно обрабатывать
документы, состоящие из многих тысяч строк, без снижения
производительности. Это побудило переписать CodeMirror по тем же
принципам. В результате появилась версия 2, которая больше не
полагалась на \texttt{contentEditable}, что значительно улучшило
производительность редактора.

Мы используем эту библиотеку для того, чтобы предоставить
пользователю возможность вводить код в интерактивном режиме прям
в веб-приложении.

\paragraph{Tippy.js}

Tippy.js --- это очень гибкая библиотека, предоставляющая
возможность создавать всплывающие подсказки при наведении мыши на
ссылку или иной элемент веб-страницы. У него есть много своих тем
оформления внешнего вида, включая возможность своей кастомизации.
Плагин Tippy.js подключает в себя различные эффекты анимации при
появлении всплывающих подсказок (англ. \textit{tooltip}). В нем
есть практически любой параметр на изменение, к примеру, скорость
появления, место появления, множество вложений и очень многое
другое.

Мы используем эту библиотеку для того, чтобы предоставить
пользователям функцию всплывающих подсказок к AST, которые
содержат более подробную информацию об атрибутах узлов.

\paragraph{Highlighter.js}

Highlight.js --- это подсветка синтаксиса, написанная на
JavaScript. Он работает как в браузере, так и на сервере. Он может
работать практически с любой разметкой, не зависит от других
фреймворков и имеет автоматическое определение языка.

Мы используем эту библиотеку для того чтобы подсвечивать синтаксис
листинга ассемблерного кода, полученного на этапе кодогенерации.

\subsubsection{Описание пользовательского интерфейса}

Весь пользовательский интерфейс веб-приложения состоит из пяти
модулей: редактор исходного текста, визуализаторы потоков токенов,
CST и AST, а также модуль отображения результатов кодогенерации.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{img/full_ui_showcase.png}
	\caption{Внешний вид интерфейса веб-приложения. На картинке
	можно видеть все модули UI.}
\end{figure}

Рассмотрим более подробно модуль редактора исходного текста. В
качестве редактора, как уже было сказано выше мы используем
библиотеку CodeMirror. Редактор поддерживает подсветку синтаксиса,
подсветку парных скобок, a также мощнейший движок эмуляции
редактора Vim.

Как можно видеть на скриншотах, в редакторе подсвечиваются строки
кода, которые пользователь выделил курсором мыши в любом другом
модуле.

При наличие ошибки в исходном коде, в редакторе будет отображено
диагностическое сообщение, полченное от компилятора:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{img/lex_error.png}
	\caption{Вывод диагностического сообщения в редакторе при
	лексической ошибке в исходном коде.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{img/cst_error.png}
	\caption{Вывод диагностического сообщения в редакторе при
	обнаружении синтаксической ошибки при парсинге исходного кода.}
\end{figure}

Далее остановим наше внимание на модуле отображения дерева
разбора. Модуль представляет собой визуализацию CST, полученного
после прохода синтаксического анализа. В модуле присутствует
функционал сворачивания дерева на любом из нужных улов. При
наведении курсором мыши на узел, он и его дочернии узлы
подсвечиваются, а неактивные части дерева затемняются для более
комфортной работы с представлениями.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{img/cst_fold_highlight.png}
	\caption{На изображении можно наблюдать функционал сворачивания
	узлов дерева и выделение поддерва при наведении курсором мыши на
	элемент.}
\end{figure}

\gostStructureElement{Заключение}

В результате преддипломной практики было разработано программное
обеспечение компилятора с возможность интроспекции промежуточных
представлений, а также графический интерфейс пользователя к нему.

Для достижения поставленных целей были выполнены следующие задачи: 

\begin{itemize}
	\item Обоснование необходимости разработки программного
		обеспечения.
	\item Анализ предметной области.
	\item Сравнительный анализ существующих решений компиляторов для
		образовательных целей.
	\item Определение функционала системы.
	\item Обоснование выбора используемых технологий.
	\item Разработка и реализация компилятора.
	\item Разработка клиент-серверного приложения графического
		пользовательского интерфейса компилятора.
	\item Тестирование разработанного программного обеспечения.
\end{itemize}

Также:

\begin{itemize}
	\item Были развиты навыки разработки архитектуры программного
		обеспечения.
	\item Были развиты навыки оформления рабочих результатов в виде
		научно-технического отчета.
	\item Были изучены основные требования, предъявляемые к
		содержанию и оформлению научно-исследовательских работ.
	\item Цель выпускной квалификационной работы была достигнута и
		все поставленные задачи для достижения цели были успешно.
\end{itemize}

\pagebreak
\printbibliography[heading=bibintoc,title={Список использованной литературы}]

\gostStructureElement{Приложение А}
\addtocontents{toc}{\protect\setcounter{tocdepth}{-1}}
\setcounter{section}{0}

\begin{center}
	\textbf{САРАТОВСКИЙ ГОСУДАРСТВЕННЫЙ ТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ ИМЕНИ ГАГАРИНА
	Ю.А.}

	\bigskip
	\bigskip
	\bigskip
	\bigskip

	\begin{table}[H]
		\begin{tabular}{S{p{0.5\textwidth}}S{p{0.5\textwidth}}}
				\multicolumn{1}{c}{УТВЕРЖДАЮ} &
				\multicolumn{1}{c}{УТВЕРЖДАЮ} \\

				Руководитель (должность, наименование предприятия --- заказчика АС) &
				Руководитель (должность, наименование предприятия --- заказчика АС) \\

				Личная подпись Расшифровка подписи &
				Личная подпись Расшифровка подписи \\

				Печать & Печать \\
				Дата & Дата
			\end{tabular}
	\end{table}

	\textbf{Программного обеспечения \enquote{Компилятор языка C}}

	\textbf{ТЕХНИЧЕСКОЕ ЗАДАНИЕ}

	На 21 листе

	Действует с \enquote{\_\_\_} \_\_\_\_\_\_\_\_ 2022 г.
\end{center}

\bigskip
\bigskip

\begin{flushleft}
	СОГЛАСОВАНО \\
	Руководитель (должность, наименование согласующей организации) \\
	Личная подпись Расшифровка подписи \\
	Печать \\
	Дата \\
\end{flushleft}

\vfill

\begin{center}
	Саратов 2022
\end{center}

\clearpage
\section{ОБЩИЕ ПОЛОЖЕНИЯ}

\subsection{Полное наименование системы и ее условное обозначение}

Полное наименование системы: \enquote{Автоматизированная
информационная система “Компилятор языка C”}.

Краткое наименование системы: АИС \enquote{Компилятор}.

\subsection{Номер договора (контракта)}

Шифр темы: АИС-КА-ФА-07.

Номер контракта: №1/11-11-11-001 от 29.09.2021.

\subsection{Наименования организации-заказчика
и\\организаций-участников работ}

Заказчиком системы является Саратовский Государственный
технический университет имени Гагарина Ю.А. Адрес заказчика:
410054, г. Саратов, ул. Политехническая, д. 77.

Разработчиком системы является Нефедов Данил Вадимович. Адрес
разработчика: 415011, г. Саратов, ул. Московская, д. 27.

\subsection{Перечень документов, на основании которых создается
система}

Основанием для разработки компилятора \enquote{\textit{CC99}}
являются следующие документы и нормативные акты:

\begin{itemize}
	\item ISO/IEC 9989:1999. Programming languages --- C.
	\item Intel® 64 and IA-32 Architectures Software Developer’s
		Manual, Volume 1: Basic Architecture.
	\item The Intel® 64 and IA-32 Architectures Software Developer’s
		Manual, Volumes 2A, 2B, 2C \& 2D: Instruction Set Reference.
	\item The Intel® 64 and IA-32 Architectures Software Developer’s
		Manual, Volumes 3A, 3B, 3C \& 3D: System Programming Guide.
	\item The Intel® 64 and IA-32 Architectures Software Developer’s
		Manual, Volume 4: Model-Specific Registers.
	\item System V Application Binary Interface. AMD64 Architecture
		Processor Supplement (With LP64 and ILP32 Programming Models).
	\item IEEE Std 1003.1-2017.
	\item ISO/IEC JTC 1 Working Group. Rationale for International
		Standard --- Programming Languages --- C.
	\item Documentation for GNU binutils 2.37.
\end{itemize}

\subsection{Плановые сроки начала и окончания работы по созданию
системы}

Плановый срок начала работ по созданию АИС \enquote{Компилятор}
--- 29 сентября 2021 года.

Плановый срок окончания работ по созданию АИС \enquote{Компилятор}
--- 28 февраля 2022 года.

\subsection{Порядок оформления и предъявления заказчику
результатов работ по созданию системы}

Исходный код разработанного программного обеспечения, список
технических средств к закупке, а также инструкция по установке,
настройке, запуске рабочего окружения и его сопровождение должна
быть передана Заказчику в установленные им сроки. Приёмка и
проверка работоспособности системы будет осуществлена комиссией,
сформированной заказчиком.

\subsection{Перечень нормативно-технических
документов,\\методических материалов, использованных
при\\разработке ТЗ}

При создании и разработки программного обеспечения и
проектно-\\эксплуатационной документации необходимо
руководствоваться требованиями следующий документов:

\begin{itemize}
	\item ГОСТ 34.602-89.
\end{itemize}

\subsection{Определения, обозначения и сокращения}

\begin{table}[H]
	\resizebox{\textwidth}{!}{
		\begin{tabular}{|Sl|Sl|}
			\hline
				\multicolumn{1}{|c|}{Сокращение} &
				\multicolumn{1}{|c|}{Расшифровка} \\
			\hline
			ТЗ & Техническое задание \\
			АИС & Автоматизированная информационная система \\
			ЯП & Язык программирования \\
			ABI & Application Binary Interface \\
			AST & Abstract Syntax Tree, абстрактное синтаксическое дерево \\
			3AC & Three Address Code \\
			SSA & Static Single Assignment form \\
			\hline
		\end{tabular}
	}
\end{table}

\clearpage
\section{НАЗНАЧЕНИЕ И ЦЕЛИ СОЗДАНИЯ СИСТЕМЫ}

\subsection{Назначение системы}

АИС \enquote{Компилятор} создается для образовательных целей и
предназначена для обучения студентов и прочих желающих внутреннему
устройству и построению в частности компиляторов, а в общем случае
--- программ\-/трансляторов с одного языка программирования в
другой.

\subsection{Цели создания системы}

Основными целями создания АИС \enquote{Компилятор} являются:

\begin{itemize}
	\item Создание компилятора языка C, который полностью или
		частично соответствует международному стандарту ISO/IEC
		9899:1999. \item Создание компилятора, который поможет
			студентам и прочим
		желающим разобраться в работе программ-компиляторов и
		программ\-/трансляторов с одного ЯП в другой.
	\item Создание компилятора, который сможет скомпилировать сам
		себя (так называемая раскрутка, англ. \textit{bootstrapping}).
\end{itemize}

Для реализации поставленных целей система должна решать следующие
задачи:

\begin{itemize}
	\item Переводить программу, написанную на ЯП C версии
		определенной и описанной в международном стандарте ISO/IEC
		9899:1999 в язык ассемблера GNU Assembler с синтаксисом AT\&T
		для архитектуры Intel® 64 в соответствии System V ABI.
	\item Иметь простой и понятный исходный код.
	\item Быть простой в использовании.
	\item Иметь возможность скомпилировать свой собственный исходный
		код.
\end{itemize}

\clearpage
\section{ТРЕБОВАНИЯ К СИСТЕМЕ}

\subsection{Требования к системе в целом}

\subsubsection{Требования к структуре и функционированию системы}

\paragraph{Перечень подсистем, их назначение и
основные\\характеристики}

В состав АИС \enquote{Компилятор} должны входить следующие
подсистемы:

\begin{itemize}
	\item Подсистема лексического анализа (лексический анализатор).
	\item Подсистема синтаксического анализа (синтаксический
		анализатор).
	\item Подсистема построения AST.
	\item Подсистема перевода AST в 3AC.
	\item Подсистема перевода 3AC в SSA.
	\item Подсистема перевода SSA в код ассемблера GNU Assembler с
		синтаксисом AT\&T для архитектуры Intel® 64 в соответствии с
		System V ABI.
\end{itemize}

Подсистема лексического анализа предназначена для а) разбиения
исходного кода входной программа, представленного в качестве
массива байт в определенной кодировке, на отдельные лексические
единицы ЯП C; б) выявления и диагностики лексических ошибок во
входной программе.

Подсистема синтаксического анализа предназначена для а) перевода
потока токенов, полученных от лексического анализатора в
синтаксическое дерево по грамматике, соответствующей грамматике
языка C, описанного международным стандартом ISO/IEC 9899:1999; б)
выявления и диагностики синтаксических ошибок во входной
программе.

Подсистема построения AST предназначена для а) перевода
синтаксического дерева, полученного от синтаксического анализатора
в AST; б) выявления и диагностики семантических ошибок во входной
программе.

Подсистема перевода AST в 3AC предназначена для перевода
абстрактного синтаксического дерева, полученного из подсистемы
построения AST, в 3AC.

Подсистема перевода 3AC в SSA предназначена для перевод 3AC,
полученного из предыдущей подсистемы в SSA.

Предназначение подсистемы перевода SSA в код ассемблера GNU
Assembler с синтаксисом AT\&T для архитектуры Intel® 64 в
соответствии с System V ABI очевидно из ее названия.

\paragraph{Требования к способам и средствам связи
для\\информационного обмена между компонентами системы}

Требования не предъявляются.

\paragraph{Требования к характеристикам взаимосвязей
создаваемой\\системы со смежными системами}

АИС \enquote{Компилятор} должна взаимодействовать со следующими
смежными системами:

\begin{itemize}
	\item Операционная система.
\end{itemize}

\paragraph{Требования к режимам функционирования системы}

Для АИС \enquote{Компилятор} определены следующие режимы
функционирования:

\begin{itemize}
	\item Нормальный режим функционирования.
\end{itemize}

В нормальном режиме функционирования системы АИС
\enquote{Компилятор} программное обеспечение обеспечивает
возможность функционирования по запросу пользователя.

\paragraph{Требования по диагностированию системы}

Требования не предъявляются.

\paragraph{Перспективы развития, модернизации системы}

АИС должна иметь возможность дальнейшей модернизации как
программного обеспечения, так комплекса технических средств.

Необходимо предусмотреть возможность добавления одного или
нескольких проходов оптимизации SSA; возможность добавления других
бэкендов компилятора --- то есть генерация другого ассемблерного
кода, кода для другой архитектуры и/или ABI.

\subsubsection{Требования к численности и квалификации персонала
системы}

Для эксплуатации АИС \enquote{Компилятор} определены следующие
роли:

\begin{itemize}
	\item Пользователь.
\end{itemize}

Основными возможностями пользователя являются:

\begin{itemize}
	\item Компиляция исходной программы.
	\item Просмотр промежуточных стадий трансляции.
\end{itemize}

Пользователи системы должны иметь опыт работы с любой командной
оболочкой совместимой со стандартом IEEE Std 1003.1-2017.

\subsubsection{Показатели назначения}

Требования на время отклика системы не налагаются и зависят от
входных данных, переданных системе на обработку.

Система должна предусматривать возможность масштабирования по
производительности и объему обрабатываемой информации без
модификации ее программного обеспечения путем модернизации
используемого комплекса технических средств.

\subsubsection{Требования к надежности}

Требования к надежности не предъявляются, так как это позволит
сильно упростить исходный код АИС для понимания.

Система не обязана сохранять работоспособность и обеспечивать
восстановление своих функций при возникновении каких-либо
внештатных ситуаций.

\subsubsection{Требования к эргономике и технической эстетике}

АИС не должна иметь визуальный графический интерфейс. Все
взаимодействие с АИС должно производится из командной оболочки
соответствующей стандарту IEEE Std 1003.1-2017.

\subsubsection{Требования к транспортабельности для подвижных АС}

Требования не предъявляются.

\subsubsection{Требования к эксплуатации, техническому
обслуживанию,\\ремонту и хранению компонентов системы}

Система должна быть рассчитана на эксплуатацию на персональных
компьютерах пользователей.

\subsubsection{Требования к защите информации от
несанкционированного\\доступа}

Требования не предъявляются.

\subsubsection{Требования по сохранности информации при авариях}

Требования не предъявляются.

\subsubsection{Требования к защите от влияния внешних воздействий}

Требования не предъявляются.

\subsubsection{Требования к патентной чистоте}

Разработка системы должна осуществляться в рамках рекомендаций по
стандартизации Р50.1.028-2001 \enquote{Информационные технологии
поддержки жизненного цикла продукции. Методология функционального
моделирования}.

\subsubsection{Требования по стандартизации и унификации}

\begin{itemize}
	\item ГОСТ 18421-93.
	\item ГОСТ 19.001-77.
	\item ГОСТ 19.005-85.
	\item ГОСТ 19.402-78.
	\item ГОСТ Р 51904-2002.
\end{itemize}

\subsubsection{Дополнительные требования}

Дополнительные требования не предъявляются.

\subsection{Требования к функциям (задачам), выполняемым\\системой}

\subsubsection{Подсистема лексического анализа}

Подсистема лексического анализа должна разбивать исходный код входной программы,
представленной в качестве массива байт в определенной кодировке, на отдельные
лексические единицы ЯП C.

Подсистема лексического анализа должна предоставлять возможность экспортировать
результат своей работы (полученный поток токенов) в произвольном формате.

Также для подсистемы допускается выявление и диагностика лексических ошибок во
входной программе с выводом диагностических сообщений пользователю, что
соответствует требованиям ISO/IEC 9899:1999.

\subsubsection{Подсистема синтаксического анализа}

Подсистема синтаксического анализа должна переводить потока токенов, полученных
от лексического анализатора в синтаксическое дерево по грамматике,
соответствующей грамматике языка C, описанного международным стандартом ISO/IEC
9899:1999.

Подсистема лексического анализа должна предоставлять возможность экспортировать
результат своей работы (полученное синтаксическое дерево) в произвольном
формате.

Также для подсистемы допускается выявление и диагностика синтаксических ошибок
во входной программе с выводом диагностических сообщений пользователю, что
соответствует требованиям ISO/IEC 9899:1999.

\subsubsection{Подсистема построения AST}

Данная подсистема должна переводит синтаксическое дерево, полученное от
синтаксического анализатора в AST.

Также подсистема должна предоставлять возможность экспортировать результат своей
работы (полученное абстрактное синтаксическое дерево) в произвольном формате.

Также для подсистемы допускается выявление и диагностика семантических ошибок во
входной программе с выводом диагностических сообщений пользователю, что
соответствует требованиям ISO/IEC 9899:1999.

\subsubsection{Подсистема перевода AST в 3AC}

Подсистема перевода AST в 3AC должна переводить абстрактное синтаксическое
дерево в 3AC. Также подсистема должна предоставлять возможность экспортировать
результат своей работы (полученный 3AC) в произвольном формате.

\subsubsection{Подсистема перевода 3AC в SSA}

Подсистема перевода 3AC в SSA должна переводить 3AC в SSA. Также подсистема
должна предоставлять возможность экспортировать результат своей работы
(полученный SSA) в произвольном формате.

\subsubsection{Подсистема перевода SSA в код ассемблера}

Подсистема должна переводить SSA в код ассемблера GNU Assembler с синтаксисом
AT\&T для архитектуры Intel® 64 в соответствии с System V ABI. Полученный
результат должен быть выведен пользователю любым способом. Например, с помощью
вывода в стандартный поток вывода или файл, указанный пользователем.

\subsection{Требования к видам обеспечения}

\subsubsection{Требования к математическому обеспечению системы}

Для лексического анализа допустимо и желательно применение готовых библиотек
программных кодов, реализующих функции работы с регулярными выражениями.

Для синтаксического анализа требуется использовать алгоритм рекурсивного спуска
как наиболее простого. Так как грамматика языка C является контекстно-зависимой,
потребуется применение постпроцессинга полученного синтаксического дерева.

\subsubsection{Требования к лингвистическому обеспечению системы}

Исходя из целей, АИС должна быть разработка с применением языка программирования
C версии, соответствующей международному стандарту ISO/IEC 9899:1999. Также
допустимо применение такого языка как GNU Make для создания системы сборки АИС.

Языком взаимодействия с пользователем является английский язык (американский).

Окончательное требования к кодировке входных данных уточняется в процессе
создания программного обеспечения АИС и не обязано быть согласовано с
Заказчиком.

\subsubsection{Требования к программному обеспечению системы}

При проектировании и разработке системы необходимо использовать только
библиотеки программных кодов с открытым исходным кодом.


Базовой программной платформой должна являться POSIX\-/совместимая операционная
система, в которой используется GNU C Library.

\subsubsection{Требования к техническому обеспечению}

Требования к техническому обеспечению не предъявляются.

\subsubsection{Требования к метрологическому обеспечению}

Требования к метрологическому обеспечению не предъявляются.

\clearpage
\section{СОСТАВ И СОДЕРЖАНИЕ РАБОТ ПО\\СОЗДАНИЮ (РАЗВИТИЮ) СИСТЕМЫ}

\begin{table}[H]
		\begin{tabular}{|Sl|S{p{7cm}}|S{p{7cm}}|}
			\hline
				\multicolumn{1}{|c|}{Этап} &
				\multicolumn{1}{|c|}{Содержание работ} &
				\multicolumn{1}{|c|}{Результаты работ} \\
			\hline

			1 &
			Разработка документов технического проекта АИС \enquote{Компилятор} &
			Документы технического проекта АИС \enquote{Компилятор} \\
			\hline

			2 &
			Проектирование, создание и тестирование программного обеспечения АИС \enquote{Компилятор} &
			Программное обеспечение АИС \enquote{Компилятор} \\
			\hline

			3 &
			Приемка АИС \enquote{Компилятор} &
			Акт о приемке АИС \enquote{Компилятор} \\
			\hline
		\end{tabular}
\end{table}

\clearpage
\section{ПОРЯДОК КОНТРОЛЯ И ПРИЕМКИ СИСТЕМЫ}

\subsection{Виды, состав, объем и методы испытаний системы}

Каждая подсистема АИС должна пройти комплексное тестирование для проверки
корректности работы. Должно быть также проведено интеграционное тестирование
каждой подсистемы по отдельности и всех вместе для выявления проблем
взаимодействия как внутри подсистем, так и подсистем между собой.

Кроме того АИС должна пройти инспекцию кода комиссией, в состав которой входят
представители Заказчика и Исполнителя. Инспекция кода должна подтвердить, что
исходный код АИС соответствует предъявляемым к нему требованиям качества.

\subsection{Общие сведения к приемке работ по стадиям}

Сдача-приемка осуществляется комиссией, в состав которой входят представители
Заказчика и Исполнителя. По результатам приемки подписывается акт приемочной
комиссии.

\subsection{Статус приемочной комиссии}

Статус приемочной комиссии определяется Заказчиком до проведения испытаний.

\clearpage
\section{ТРЕБОВАНИЯ К СОСТАВУ И СОДЕРЖАНИЮ\\РАБОТ ПО ПОДГОТОВКЕ ОБЪЕКТА\\
АВТОМАТИЗАЦИИ К ВВОДУ СИСТЕМЫ В\\ДЕЙСТВИЕ}

Требования не предъявляются.

\clearpage
\section{ТРЕБОВАНИЯ К ДОКУМЕНТИРОВАНИЮ}

Требования не предъявляются.

\clearpage
\section{ИСТОЧНИКИ РАЗРАБОТКИ}

Учебники, учебные пособия, научные работы и другие материалы по а) построению
трансляторов кода; б) формальным языкам; в) системному и низкоуровневому
программированию. Документы, приведенные в пункте 1.4.

\end{document}
